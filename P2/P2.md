# Computación en la Nube

## Práctica 2 - Base de datos, balanceo y escalado

Author: Francisco Javier López-Dufour Morales

### 1. Introducción

El objetivo de esta práctica es explorar y experimentar con las herramientas de balanceo de carga y escalado explicadas en la clase teórica.

### 2. Objetivos

### 3. Actividades

### 3.1. Despliegue y configuración de las instancias EC2

> Despliega dos instancia en EC2 con un servidor web que muestre una pagina similar pero que se pueda reconocer que es un servidor distinto. E.g. [El servidor de Gabriel 1] [Elservidor de Gabriel 2]. Estos servidores deben poder ser accedidos con un navegador desde fuera.

Lanzamos dos instancias EC2 con las siguientes características:

```
Imagen de software (AMI)
- Amazon Linux 2023 AMI 2023.5.2
- ami-0ebfd941bbafe70c6
Tipo de servidor virtual (tipo de instancia)
- t2.nano
Firewall (grupo de seguridad)
- SG-SSH-HTTP-HTTPS
Almacenamiento (volúmenes)
- Volúmenes: 1 (8 GiB)
```

Configuración del grupo de seguridad:

| Nombre | ID de la regla del grupo de seguridad | Versión de IP | Tipo               | Protocolo | Intervalo de puertos | Origen        | Descripción |
|--------|---------------------------------------|---------------|--------------------|-----------|----------------------|---------------|-------------|
|        | sgr-07861fea6d1e6cb9e                | IPv4         | HTTPS              | TCP       | 443                  | 0.0.0.0/0     |             |
|        | sgr-002bcf0775e6ab4ee                | IPv4         | SSH                | TCP       | 22                   | 0.0.0.0/0     |             |
|        | sgr-0a8dce6066c4ab592                | IPv4         | TCP personalizado  | TCP       | 0                    | 0.0.0.0/0     |             |
|        | sgr-048cf1efa02df6e89                | IPv4         | HTTP               | TCP       | 80                   | 0.0.0.0/0     |             |

Instancias EC2 ejecutándose:

![EC2 Dashboard running instances](./img/ec2-running-instances.png)

Configuración de los servidores web:

1. Conectamos a las instancias EC2 mediante SSH.
2. Subimos y ejecutamos el script de setup_server.sh:

```
chmod +x setup_server.sh
sudo ./setup_server.sh
```

// Test local server
curl http://localhost

3. Comprobamos que el servidor web se ejecuta correctamente accediendo a la IP pública de la instancia EC2 desde un navegador.

![Web server 1](./img/web-server-1.png)
![Web server 2](./img/web-server-2.png)

### 3.2. Despliegue de un "load balancer" 

> Despliega un “load balancer” que distribuya las peticiones entre los dos servidores a partes iguales.

Antes de nada, es necesario crear un grupo de destino (target group) para los servidores web.

Desde el menu de EC2, accedemos a "Grupos de destino".

* Configuración básica:

  * Tipo de destino: Instancias de EC2
  * Nombre del grupo de destino: lb-pr2-p2-tg
  * Protocolo: HTTP
    * Puerto: 80
  * Tipo de dirección IP: IPv4
  * VPC: default
  * Versión del protocolo: HTTP1

* Comprobaciones de estado
  * Protocolo de comprobación de estado: HTTP
  * Ruta: /
  * Configuración avanzada: default

* Registrar destinos:

![Target group](./img/target-group.png)
![Target group details](./img/target-group-details.png)

A continuación, creamos el **balanceador de carga**.

Desde el menu de EC2, accedemos a "Balanceadores de carga".

A la hora de crear un balanceador de carga, AWS nos permite elegir entre varios tipos de balanceadores de carga:

* Balanceador de carga de aplicaciones
* Balanceador de carga de red
* Equilibrador de carga de gateway

En nuestro caso, como queremos balancear el tráfico HTTP, usaremos un balanceador de carga de aplicaciones.

![Load balancer type](./img/load-balancer-type.png)

En la pestaña "Configure subnet settings" seleccionamos las subredes a las que se conectará el balanceador de carga.

Configuración:

* Configuración básica:
  * Nombre: lb-pr2-p2
  * Esquema: Expuesto a Internet
  * Tipo de direcciones IP: IPv4
* Mapa de red:
  * VPC: default
  * Zonas de disponibilidad: us-east-1a, us-east-1b
* Grupos de seguridad: SG-SSH-HTTP-HTTPS
* Agentes de escucha y direccionamiento:
  * Protocolo: HTTP
  * Puerto: 80
  * Grupo de destino: lb-pr2-p2-tg

Resumen

![Load balancer details](./img/load-balancer-details.png)

![Load balancer details 2](./img/load-balancer-details-2.png)

Una vez creado el balanceador de carga, obtenemos la dirección DNS del balanceador de carga.

```
lb-pr2-p2-1198883516.us-east-1.elb.amazonaws.com
```

Comprobamos que el balanceador de carga distribuye las peticiones entre los servidores web.

```bash
(base) fran.@MacBook ~ % curl lb-pr2-p2-1198883516.us-east-1.elb.amazonaws.com
<h1>Express Server on AWS EC2</h1><p>Hostname: ip-172-31-45-209.ec2.internal</p>%               

(base) fran.@MacBook ~ % curl lb-pr2-p2-1198883516.us-east-1.elb.amazonaws.com
<h1>Express Server on AWS EC2</h1><p>Hostname: ip-172-31-33-205.ec2.internal</p>%                                                   
```

### 3.3. Despliegue de un "auto scaling group"

> Prepara un “template” de instancia para EC2 para generar servidores web. Con el “template” declarar un “Auto-Scaling Group”(ASG) que tenga como mínimo una instancia y como máximo 2. El ASG debe añadirse al “load balancer” previamente desplegado. Comprueba que el ASG mantiene al menos una instancia viva y que el “load balancer” le manda peticiones entrantes.

Para crear un Auto Scaling Group (ASG) necesitamos un Launch Template.

Desde el menu de EC2, accedemos a EC2 > ... > "Crear plantilla de lanzamiento".

* Crear un nuevo Launch Template:

  * Nombre: `lt-pr2-p2`
  * Descripción: Launch template for EC2 instances
  * Versión: 1
  * Tipo de instancia: `t2.nano`
  * AMI: `Amazon Linux 2023 AMI 2023.5.2`
  * Tipo de almacenamiento: `EBS`
  * Tamaño de almacenamiento: `8 GiB`
  * Grupo de seguridad: `SG-SSH-HTTP-HTTPS`
  * Clave de par: 
  * Tipo de red: `default`
  * Datos de usuario: `setup_server.sh` (script de configuración de la instancia)

![Launch template](./img/launch-template.png)

Una vez creado el Launch Template, creamos un Auto Scaling Group.

Desde el menu de EC2, accedemos a EC2 > Grupos de Auto Scaling.

* Crear un nuevo Auto Scaling Group:

  * Nombre: `asg-pr2-p2`
  * Plantilla de lanzamiento: `lt-pr2-p2`
  * Configuración de grupo:
    * Capacidad deseada: 1
    * Capacidad mínima: 1
    * Capacidad máxima: 2
    * Redes: `default`
    * Subredes: `us-east-1a`, `us-east-1b`
    * Grupo de destino: `lb-pr2-p2-tg`
    * Grupo de equilibrador de carga: `lb-pr2-p2`
    * Configuración de escalado:
      * Escalado de destino:
        * Grupo de destino: `lb-pr2-p2-tg`
    * Política de mantenimiento de instancias:+
      * Comporamiento mixto: Sin política. 

![Auto Scaling Group](./img/auto-scaling-group.png)
![Auto Scaling Group 2](./img/auto-scaling-group-2.png)

Una vez creado el Auto Scaling Group, detenemos todas las instancias y comprobamos que mantiene al menos una instancia viva de forma automática.

```bash
(base) franciscoj.@MacBook ~ % curl lb-pr2-p2-1198883516.us-east-1.elb.amazonaws.com
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Francisco Javier López-Dufour Morales
```

Y comprobamos el estado del Load Balancer.

![Load balancer instances](./img/load-balancer-instances.png)

### 3.4. Despliegue de una base de datos "relacional"

> Investigar y desplegar una base de datos de su elección dentro de AWS. Demostrar que funcione y estimar el coste de utilización.

AWS ofrece varios servicios de bases de datos relacionales mediante Amazon RDS (Relational Database Service).

En este caso, vamos a desplegar una base de datos MySQL.

Desde el menu de RDS, accedemos a "Bases de datos" y creamos una nueva base de datos.

* Crear una nueva base de datos:

  * Motor: MySQL
  * Versión: MySQL 8.0.25
  * Plantilla: Free tier
  * Configuración de la base de datos:
    * Nombre de la base de datos: `pr2-p2-db`
    * Nombre de usuario maestro: `admin`
    * Contraseña maestra: `password`
    * Confirmar contraseña: `password`
  * Configuración de la instancia:
    * Tipo de instancia: `db.t4g.micro`
    * Almacenamiento: `20 GiB`
    * Clase de almacenamiento: `SSD`
    * Zona de disponibilidad: `us-east-1a`
    * Grupo de seguridad de la base de datos: `SG-SSH-HTTP-HTTPS`
      * Nota: Añadir una regla de seguridad para permitir el tráfico MySQL desde el grupo de seguridad de las instancias EC2.
    * Configuración adicional: default

![RDS database](./img/rds-database.png)

```bash
(base) franciscoj.@MacBook ~ % mysql -h pr2-p2-db.cntejlvl3d16.us-east-1.rds.amazonaws.com -u admin -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 28
Server version: 8.0.35 Source distribution

Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
```

Comprobamos que la base de datos MySQL se ha desplegado correctamente y podemos conectarnos a ella.

Coste de utilización:

![RDS database cost](./img/rds-database-cost.png)

#### 3.X. Diagrama de la infraestructura desplegada

#### 3.X. Presupuesto y estimación de gasto de los recursos desplegados

### 4. Conclusiones

### 5. Bibliografía

### 6. Anexos

```setup_server.sh
#!/bin/bash

# Update the system
sudo yum update -y

# Install Node Version Manager (nvm)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash

# Load nvm
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

# Install Node.js
nvm install 16

# Create a new directory for the application
mkdir ~/myapp
cd ~/myapp

# Initialize a new Node.js project and install Express
npm init -y
npm install express

# Create a simple Express server
cat << EOF > app.js
const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req, res) => {
  res.send('<h1>Express Server on AWS EC2</h1><p>Hostname: ' + require('os').hostname() + '</p>');
});

app.listen(port, () => {
  console.log(\`Server running at http://localhost:\${port}\`);
});
EOF

# Install PM2 globally
npm install pm2 -g

# Start the Express server with PM2
pm2 start app.js

# Configure PM2 to start on system boot
pm2 startup
pm2 save

# Install and configure nginx as a reverse proxy
sudo yum install nginx

# Configure nginx
sudo tee /etc/nginx/conf.d/myapp.conf > /dev/null <<EOF
server {
    listen 80;
    server_name _;

    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_cache_bypass \$http_upgrade;
    }
}
EOF

# Remove the default nginx configuration
sudo rm /etc/nginx/conf.d/default.conf

# Start and enable nginx
sudo systemctl start nginx
sudo systemctl enable nginx

# Print the public IP address
echo "Setup complete. Your server's public IP address is:"
curl -s http://169.254.169.254/latest/meta-data/public-ipv4

echo "You can access your Express server by visiting this IP address in your web browser."
```
